<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SmartPark Navigation</title>
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(-45deg, #667eea, #764ba2, #f093fb, #f5576c);
      background-size: 400% 400%;
      animation: gradientFlow 15s ease infinite;
      color: #fff;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    @keyframes gradientFlow {
      0%, 100% { background-position: 0% 50%; }
      25% { background-position: 100% 50%; }
      50% { background-position: 100% 100%; }
      75% { background-position: 0% 100%; }
    }
    
    .app-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      position: relative;
    }
    
    /* Glass Card Base */
    .glass-card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 24px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    /* Header */
    .header {
      text-align: center;
      margin-bottom: 30px;
      opacity: 0;
      animation: fadeInDown 1s ease-out 0.2s forwards;
    }
    
    .title {
      font-size: clamp(2.5rem, 6vw, 4rem);
      font-weight: 900;
      background: linear-gradient(135deg, #fff 0%, rgba(255,255,255,0.8) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 8px;
      letter-spacing: -0.03em;
    }
    
    .subtitle {
      font-size: 1.1rem;
      opacity: 0.9;
      font-weight: 500;
    }

    /* Time Display */
    .time-display {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 20px;
      text-align: center;
      color: white;
      font-weight: 600;
    }

    .current-time {
      font-size: 18px;
      margin-bottom: 8px;
    }

    .timezone-info {
      font-size: 14px;
      opacity: 0.8;
    }
    
    /* Status Bar */
    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 30px;
      margin-bottom: 30px;
      opacity: 0;
      animation: fadeInUp 1s ease-out 0.4s forwards;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1rem;
      font-weight: 600;
    }
    
    .status-icon {
      font-size: 1.3rem;
    }
    
    .timer {
      background: rgba(245, 87, 108, 0.9);
      padding: 10px 20px;
      border-radius: 20px;
      font-weight: 700;
      animation: timerPulse 2s infinite;
    }
    
    @keyframes timerPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    /* Main Layout */
    .main-layout {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 30px;
      margin-bottom: 30px;
      opacity: 0;
      animation: fadeInUp 1s ease-out 0.6s forwards;
    }
    
    /* Navigation Steps */
    .steps-panel {
      padding: 30px;
      height: fit-content;
    }
    
    .steps-title {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 25px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    
    .step-item {
      display: flex;
      align-items: center;
      padding: 18px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
      position: relative;
    }
    
    .step-item:last-child {
      border-bottom: none;
    }
    
    .step-item.active {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 18px 15px;
      margin: 5px -15px;
      transform: translateX(5px);
      box-shadow: 0 4px 20px rgba(255, 255, 255, 0.1);
    }
    
    .step-number {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      margin-right: 15px;
      transition: all 0.3s ease;
      font-size: 0.9rem;
    }
    
    .step-item.active .step-number {
      background: linear-gradient(135deg, #4ECDC4, #44A08D);
      animation: stepGlow 2s infinite;
    }
    
    @keyframes stepGlow {
      0%, 100% { box-shadow: 0 0 15px rgba(78, 205, 196, 0.5); }
      50% { box-shadow: 0 0 25px rgba(78, 205, 196, 0.8); }
    }
    
    .step-text {
      flex: 1;
    }
    
    .step-title {
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 4px;
    }
    
    .step-detail {
      font-size: 0.85rem;
      opacity: 0.8;
      line-height: 1.3;
    }
    
    /* Parking Layout Container */
    .layout-container {
      padding: 30px;
      position: relative;
    }
    
    .layout-title {
      text-align: center;
      font-size: 1.3rem;
      font-weight: 600;
      margin-bottom: 25px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    
    /* Floor Selector */
    .floor-selector {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 25px;
      flex-wrap: wrap;
    }
    
    .floor-btn {
      padding: 12px 20px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      color: rgba(255, 255, 255, 0.8);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: inherit;
      font-size: 0.9rem;
    }
    
    .floor-btn.active {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
      color: #fff;
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(255, 255, 255, 0.1);
    }
    
    /* Division Layout (2x5 grid) */
    .division-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 15px;
      margin-bottom: 30px;
      min-height: 200px;
    }
    
    .division-card {
      background: rgba(255, 255, 255, 0.08);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      min-height: 90px;
    }
    
    .division-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      transition: left 0.5s ease;
    }
    
    .division-card:hover::before {
      left: 100%;
    }
    
    .division-card:hover {
      transform: translateY(-4px);
      border-color: rgba(255, 255, 255, 0.3);
      box-shadow: 0 8px 25px rgba(255, 255, 255, 0.1);
    }
    
    .division-card.selected {
      background: linear-gradient(135deg, rgba(78, 205, 196, 0.3), rgba(68, 160, 141, 0.3));
      border-color: #4ECDC4;
      transform: translateY(-4px);
      box-shadow: 0 8px 25px rgba(78, 205, 196, 0.3);
    }
    
    .division-card.user-division {
      background: linear-gradient(135deg, rgba(240, 147, 251, 0.3), rgba(245, 87, 108, 0.3));
      border-color: #f093fb;
      animation: userDivisionPulse 3s infinite;
    }
    
    @keyframes userDivisionPulse {
      0%, 100% { box-shadow: 0 0 20px rgba(240, 147, 251, 0.4); }
      50% { box-shadow: 0 0 30px rgba(240, 147, 251, 0.7); }
    }
    
    .division-number {
      font-size: 1.2rem;
      font-weight: 700;
      margin-bottom: 5px;
    }
    
    .division-status {
      font-size: 0.75rem;
      opacity: 0.8;
      font-weight: 500;
    }
    
    /* Spot Layout Grid */
    .spots-container {
      display: none;
      margin-top: 25px;
    }
    
    .spots-container.active {
      display: block;
      animation: fadeInUp 0.5s ease-out;
    }
    
    .spots-title {
      text-align: center;
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 20px;
      color: rgba(255, 255, 255, 0.9);
    }
    
    .spots-grid {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 8px;
      max-width: 600px;
      margin: 0 auto;
    }
    
    .parking-spot {
      aspect-ratio: 1;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .spot-available {
      background: rgba(78, 205, 196, 0.3);
      border-color: rgba(78, 205, 196, 0.5);
      color: #4ECDC4;
    }
    
    .spot-available:hover {
      transform: scale(1.1);
      background: rgba(78, 205, 196, 0.5);
      box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
    }
    
    .spot-occupied {
      background: rgba(253, 121, 168, 0.3);
      border-color: rgba(253, 121, 168, 0.5);
      color: rgba(253, 121, 168, 0.8);
      cursor: not-allowed;
    }
    
    .spot-user {
      background: linear-gradient(135deg, #f093fb, #f5576c);
      border-color: #f093fb;
      color: white;
      animation: userSpotPulse 2s infinite;
      transform: scale(1.2);
      z-index: 10;
      box-shadow: 0 0 25px rgba(240, 147, 251, 0.6);
    }
    
    @keyframes userSpotPulse {
      0%, 100% { 
        box-shadow: 0 0 25px rgba(240, 147, 251, 0.6);
        transform: scale(1.2);
      }
      50% { 
        box-shadow: 0 0 35px rgba(240, 147, 251, 0.8);
        transform: scale(1.25);
      }
    }
    
    /* Controls */
    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
      opacity: 0;
      animation: fadeInUp 1s ease-out 0.8s forwards;
    }
    
    .nav-btn {
      padding: 18px 30px;
      border-radius: 25px;
      font-size: 1rem;
      font-weight: 700;
      border: none;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      font-family: inherit;
      position: relative;
      overflow: hidden;
      min-width: 180px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    
    .nav-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.6s ease;
    }
    
    .nav-btn:hover::before {
      left: 100%;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #4ECDC4, #44A08D);
      color: white;
      box-shadow: 0 8px 25px rgba(78, 205, 196, 0.4);
    }
    
    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }
    
    .btn-accent {
      background: linear-gradient(135deg, #f093fb, #f5576c);
      color: white;
      box-shadow: 0 8px 25px rgba(240, 147, 251, 0.4);
    }
    
    .nav-btn:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 35px rgba(0, 0, 0, 0.3);
    }
    
    .btn-icon {
      font-size: 1.2rem;
    }
    
    /* Info Panel */
    .info-panel {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 20px;
      padding: 20px;
      margin-top: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }
    
    .info-item {
      text-align: center;
    }
    
    .info-label {
      font-size: 0.8rem;
      opacity: 0.7;
      margin-bottom: 5px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .info-value {
      font-size: 1.1rem;
      font-weight: 600;
    }

    /* Loading States */
    .loading {
      opacity: 0.7;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    
    /* Responsive Design */
    @media (max-width: 1024px) {
      .main-layout {
        grid-template-columns: 1fr;
        gap: 20px;
      }
      
      .division-grid {
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(4, 1fr);
      }
      
      .spots-grid {
        grid-template-columns: repeat(8, 1fr);
        grid-template-rows: repeat(3, 1fr);
      }
    }
    
    @media (max-width: 640px) {
      .title {
        font-size: 2.5rem;
      }
      
      .status-bar {
        flex-direction: column;
        gap: 10px;
        text-align: center;
      }
      
      .floor-selector {
        grid-template-columns: repeat(3, 1fr);
      }
      
      .controls {
        flex-direction: column;
        align-items: center;
      }
      
      .nav-btn {
        width: 100%;
        max-width: 300px;
      }
      
      .spots-grid {
        grid-template-columns: repeat(6, 1fr);
        grid-template-rows: repeat(4, 1fr);
      }
    }
    
    /* Animation keyframes */
    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Header -->
    <div class="header">
      <h1 class="title">Navigation</h1>
      <p class="subtitle">Navigate to your reserved parking spot</p>
      
      <!-- Debug Time Display -->
      <div class="time-display" id="timeDisplay">
        <div class="current-time" id="currentTime">Loading...</div>
        <div class="timezone-info">India Standard Time (IST)</div>
      </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar glass-card">
      <div class="status-item">
        <span class="status-icon">🚗</span>
        <span id="spotInfo" class="loading">Loading...</span>
      </div>
      <div class="status-item">
        <span class="status-icon">📍</span>
        <span id="locationInfo" class="loading">Loading...</span>
      </div>
      <div class="status-item timer">
        <span class="status-icon">⏱️</span>
        <span id="timeRemaining" class="loading">Loading...</span>
      </div>
    </div>

    <!-- Main Layout -->
    <div class="main-layout">
      <!-- Navigation Steps -->
      <div class="steps-panel glass-card">
        <h3 class="steps-title">
          <span>🧭</span>
          <span>Your Route</span>
        </h3>
        <div id="navigationSteps">
          <!-- Steps will be generated here -->
        </div>
      </div>

      <!-- Parking Layout -->
      <div class="layout-container glass-card">
        <h3 class="layout-title">
          <span>🗺️</span>
          <span>Parking Layout</span>
        </h3>
        
        <!-- Floor Selector -->
        <div class="floor-selector">
          <button class="floor-btn" data-floor="1">Floor 1</button>
          <button class="floor-btn" data-floor="2">Floor 2</button>
          <button class="floor-btn" data-floor="3">Floor 3</button>
          <button class="floor-btn" data-floor="4">Floor 4</button>
          <button class="floor-btn" data-floor="5">Floor 5</button>
        </div>

        <!-- Division Grid (2x5) -->
        <div class="division-grid" id="divisionGrid">
          <!-- Divisions will be generated here -->
        </div>

        <!-- Spots Container -->
        <div class="spots-container" id="spotsContainer">
          <div class="spots-title">Division <span id="selectedDivisionName">-</span> Spots</div>
          <div class="spots-grid" id="spotsGrid">
            <!-- Individual parking spots will be generated here -->
          </div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel">
          <div class="info-item">
            <div class="info-label">Your Spot</div>
            <div class="info-value" id="infoSpot">-</div>
          </div>
          <div class="info-item">
            <div class="info-label">Division</div>
            <div class="info-value" id="infoDivision">-</div>
          </div>
          <div class="info-item">
            <div class="info-label">Floor</div>
            <div class="info-value" id="infoFloor">-</div>
          </div>
          <div class="info-item">
            <div class="info-label">Entrance</div>
            <div class="info-value" id="infoEntrance">-</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Controls -->
    <div class="controls">
      <button class="nav-btn btn-primary" onclick="startNavigation()">
        <span class="btn-icon">🧭</span>
        <span>Start Navigation</span>
      </button>
      <button class="nav-btn btn-secondary" onclick="goToDashboard()">
        <span class="btn-icon">←</span>
        <span>Back to Dashboard</span>
      </button>
      <button class="nav-btn btn-accent" onclick="extendBooking()">
        <span class="btn-icon">⏱️</span>
        <span>Extend Booking</span>
      </button>
    </div>
  </div>

  <script>
    // FIXED: Proper Indian time handling
    function getIndianTime(date = new Date()) {
      // Create a new date in Indian timezone
      const utc = date.getTime() + (date.getTimezoneOffset() * 60000);
      const indianTime = new Date(utc + (5.5 * 3600000)); // IST is UTC+5:30
      return indianTime;
    }

    function getIndianTimeISO(date = new Date()) {
      const indianTime = getIndianTime(date);
      return indianTime.toISOString();
    }

    function formatIndianTime(date = new Date()) {
      const indianTime = getIndianTime(date);
      return indianTime.toLocaleString('en-IN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });
    }

    // Update time display every second
    function updateTimeDisplay() {
      const currentTimeEl = document.getElementById('currentTime');
      if (currentTimeEl) {
        currentTimeEl.textContent = formatIndianTime();
      }
    }

    // Configuration
    const PARKING_CONFIG = {
      FLOORS: 5,
      DIVISIONS_PER_FLOOR: 10,
      SPOTS_PER_DIVISION: 20,
      TOTAL_SPOTS_PER_FLOOR: 200
    };

    // Real AWS API Configuration (copied from smartpark.html)
    const SmartParkAPI = {
      baseUrl: 'https://edblff9w00.execute-api.ap-south-1.amazonaws.com/prod',
      
      // Test connection to AWS backend
      async testConnection() {
        try {
          console.log('🔗 Testing AWS backend connection...');
          
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);
          
          const response = await fetch(`${this.baseUrl}/health`, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            signal: controller.signal,
            mode: 'cors'
          });
          
          clearTimeout(timeoutId);
          
          if (response.ok) {
            const data = await response.json();
            console.log('✅ AWS Backend health check passed:', data.status || 'healthy');
            return true;
          } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
        } catch (error) {
          console.error('❌ AWS Backend connection failed:', error);
          return false;
        }
      },

      // Get parking layout from AWS /slots endpoint
      async getParkingLayout() {
        try {
          console.log('📡 Attempting to load parking data from AWS /slots endpoint...');
          
          try {
            const response = await fetch(`${this.baseUrl}/slots`, {
              method: 'GET',
              headers: { 
                'Content-Type': 'application/json',
                'Accept': 'application/json'
              }
            });

            if (response.ok) {
              const result = await response.json();
              console.log('📊 Raw AWS slots response:', result);
              
              // Convert AWS slots data to frontend format
              const convertedLayout = this.convertAWSDataToFrontendFormat(result);
              
              if (convertedLayout && convertedLayout.floors) {
                console.log('✅ Loaded parking data from AWS /slots endpoint');
                console.log(`📊 AWS provided ${Object.keys(result.slots || result || []).length} real sensor slots`);
                
                // Save to localStorage as cache
                localStorage.setItem('parking_layout', JSON.stringify(convertedLayout));
                return { success: true, layout: convertedLayout };
              }
            } else {
              console.warn('⚠️ AWS /slots endpoint returned:', response.status);
            }
          } catch (fetchError) {
            console.warn('⚠️ Failed to fetch from AWS /slots:', fetchError.message);
          }
          
          console.log('📁 Loading parking layout from local storage (fallback)...');
          
          // Fallback to local data
          let layout = JSON.parse(localStorage.getItem('parking_layout') || 'null');
          
          if (!layout || !layout.floors) {
            console.log('🏗️ Generating fresh parking layout...');
            layout = this.generateDefaultLayout();
            localStorage.setItem('parking_layout', JSON.stringify(layout));
          }
          
          console.log('✅ Parking layout loaded from local storage');
          return { success: true, layout: layout };
          
        } catch (error) {
          console.error('Failed to load parking layout:', error);
          const fallbackLayout = this.generateDefaultLayout();
          return { success: true, layout: fallbackLayout };
        }
      },

      // Convert AWS slots data to frontend format (exact copy from smartpark.html)
      convertAWSDataToFrontendFormat(awsData) {
        try {
          console.log('🔄 Converting AWS data to frontend format...');
          
          // Handle different possible response formats
          let slotsArray = [];
          if (awsData.slots) {
            slotsArray = awsData.slots;
          } else if (Array.isArray(awsData)) {
            slotsArray = awsData;
          } else if (awsData.Items) {
            slotsArray = awsData.Items;
          } else {
            console.warn('⚠️ Unknown AWS data format:', awsData);
            return null;
          }

          // Initialize frontend structure
          const frontendSlots = {};
          
          // Initialize 5 floors with 10 divisions each, 20 spots per division
          for (let floor = 1; floor <= 5; floor++) {
            frontendSlots[floor.toString()] = {};
            for (let division = 1; division <= 10; division++) {
              frontendSlots[floor.toString()][division.toString()] = {};
              for (let spot = 1; spot <= 20; spot++) {
                // Default to available if not in AWS
                frontendSlots[floor.toString()][division.toString()][spot.toString()] = {
                  id: `${floor}-${division.toString().padStart(2, '0')}-${spot.toString().padStart(2, '0')}`,
                  available: Math.random() > 0.3, // Default random availability
                  floor: floor,
                  division: division,
                  spotNumber: spot,
                  bookedBy: null,
                  isUserControlled: false,
                  lastSensorUpdate: getIndianTimeISO(),
                  sensorStatus: 'active',
                  dataSource: 'default'
                };
              }
            }
          }

          // Map AWS slots to frontend format
          slotsArray.forEach(awsSlot => {
            const converted = this.convertAWSSlotToFrontend(awsSlot);
            if (converted) {
              const { floor, division, spot } = converted;
              if (frontendSlots[floor] && frontendSlots[floor][division] && frontendSlots[floor][division][spot]) {
                frontendSlots[floor][division][spot] = {
                  ...frontendSlots[floor][division][spot],
                  available: (awsSlot.status === 'available' || awsSlot.status === 'free') && !awsSlot.isUserControlled,
                  bookedBy: awsSlot.vehicleId || awsSlot.vehicle_id || null,
                  isUserControlled: awsSlot.isUserControlled || false,
                  lastSensorUpdate: awsSlot.lastUpdated || awsSlot.last_updated || getIndianTimeISO(),
                  sensorStatus: awsSlot.status || 'active',
                  dataSource: 'aws_dynamodb'
                };
              }
            }
          });

          // Create frontend layout structure
          const layout = {
            version: "1.0",
            created: getIndianTimeISO(),
            lastModified: getIndianTimeISO(),
            totalFloors: 5,
            divisionsPerFloor: 10,
            spotsPerDivision: 20,
            floors: frontendSlots,
            activeBookings: [],
            bookingHistory: [],
            dataSource: 'aws_dynamodb',
            totalSlotsFromAWS: slotsArray.length
          };

          console.log(`✅ Converted ${slotsArray.length} AWS slots to frontend format`);
          return layout;

        } catch (error) {
          console.error('Error converting AWS data:', error);
          return null;
        }
      },

      // Convert individual AWS slot to frontend coordinates (exact copy from smartpark.html)
      convertAWSSlotToFrontend(awsSlot) {
        try {
          // Handle different slot ID formats
          let spotId = awsSlot.spotId || awsSlot.spot_id || awsSlot.id;
          
          if (!spotId) {
            console.warn('⚠️ No spot ID found in AWS slot:', awsSlot);
            return null;
          }

          // Try different format patterns
          let match;
          
          // Format: F1-001, F2-045, etc.
          match = spotId.match(/^F(\d+)-(\d+)$/);
          if (match) {
            const floor = parseInt(match[1]);
            const linearSlot = parseInt(match[2]);
            
            // Convert linear slot to division/spot
            const division = Math.ceil(linearSlot / 20);
            const spot = linearSlot - ((division - 1) * 20);
            
            if (floor >= 1 && floor <= 5 && division >= 1 && division <= 10 && spot >= 1 && spot <= 20) {
              return {
                floor: floor.toString(),
                division: division.toString(),
                spot: spot.toString()
              };
            }
          }

          // Format: 1-05-10 (already frontend format)
          match = spotId.match(/^(\d+)-(\d+)-(\d+)$/);
          if (match) {
            const floor = parseInt(match[1]);
            const division = parseInt(match[2]);
            const spot = parseInt(match[3]);
            
            if (floor >= 1 && floor <= 5 && division >= 1 && division <= 10 && spot >= 1 && spot <= 20) {
              return {
                floor: floor.toString(),
                division: division.toString(),
                spot: spot.toString()
              };
            }
          }

          // Format: Floor1_Slot001, etc.
          match = spotId.match(/^Floor(\d+)_Slot(\d+)$/);
          if (match) {
            const floor = parseInt(match[1]);
            const linearSlot = parseInt(match[2]);
            
            const division = Math.ceil(linearSlot / 20);
            const spot = linearSlot - ((division - 1) * 20);
            
            if (floor >= 1 && floor <= 5 && division >= 1 && division <= 10 && spot >= 1 && spot <= 20) {
              return {
                floor: floor.toString(),
                division: division.toString(),
                spot: spot.toString()
              };
            }
          }

          console.warn(`⚠️ Could not parse spot ID format: ${spotId}`);
          return null;
          
        } catch (error) {
          console.error('Error converting AWS slot:', error);
          return null;
        }
      },

      // Generate default layout (exact copy from smartpark.html)
      generateDefaultLayout() {
        const layout = { 
          version: "1.0",
          created: getIndianTimeISO(),
          lastModified: getIndianTimeISO(),
          totalFloors: 5,
          divisionsPerFloor: 10,
          spotsPerDivision: 20,
          floors: {},
          activeBookings: [],
          bookingHistory: []
        };
        
        // Generate floors as objects with string keys
        for (let floor = 1; floor <= 5; floor++) {
          layout.floors[floor.toString()] = {};
          
          for (let division = 1; division <= 10; division++) {
            layout.floors[floor.toString()][division.toString()] = {};
            
            for (let spot = 1; spot <= 20; spot++) {
              const spotId = `${floor}-${division.toString().padStart(2, '0')}-${spot.toString().padStart(2, '0')}`;
              layout.floors[floor.toString()][division.toString()][spot.toString()] = {
                id: spotId,
                available: Math.random() > 0.3,
                floor: floor,
                division: division,
                spotNumber: spot,
                bookedBy: null,
                bookedAt: null,
                bookedUntil: null,
                bookingId: null,
                isUserControlled: false,
                lastSensorUpdate: getIndianTimeISO(),
                sensorStatus: 'active'
              };
            }
          }
        }
        
        return layout;
      },

      // Convert frontend spot ID to AWS format (exact copy from smartpark.html)
      convertFrontendToAWSFormat(frontendId) {
        try {
          const parts = frontendId.split('-');
          if (parts.length !== 3) return frontendId; // Return as-is if not standard format
          
          const floor = parseInt(parts[0]);
          const division = parseInt(parts[1]);
          const spot = parseInt(parts[2]);
          
          // Convert to linear slot number
          const linearSlot = (division - 1) * 20 + spot;
          
          // Return in F1-001 format (your AWS format)
          return `F${floor}-${linearSlot.toString().padStart(3, '0')}`;
          
        } catch (error) {
          console.error('Error converting frontend spot:', error);
          return frontendId; // Return original if conversion fails
        }
      },

      // FIXED: Get user booking data with proper error handling
      async getUserBooking() {
        try {
          console.log('📡 Getting user booking data...');
          
          // First try to get from localStorage (current booking)
          const currentBooking = localStorage.getItem('currentBooking');
          if (currentBooking) {
            try {
              const booking = JSON.parse(currentBooking);
              console.log('📋 Found current booking in localStorage:', booking);
              
              // Check if booking is still active using Indian time
              const now = getIndianTime();
              const endTime = getIndianTime(new Date(booking.endTime));
              
              if (now <= endTime) {
                console.log('✅ Current booking is still active');
                
                // Ensure spotData exists
                if (!booking.spotData && booking.spotId) {
                  console.log('🔧 Creating missing spotData from spotId:', booking.spotId);
                  const spotParts = booking.spotId.split('-');
                  if (spotParts.length === 3) {
                    booking.spotData = {
                      id: booking.spotId,
                      floor: parseInt(spotParts[0]),
                      division: parseInt(spotParts[1]),
                      spotNumber: parseInt(spotParts[2]),
                      closestEntrance: parseInt(spotParts[1]) <= 5 ? 'main' : 'rear'
                    };
                    console.log('✅ Created spotData:', booking.spotData);
                  }
                }
                
                return { success: true, data: booking };
              } else {
                console.log('⏰ Current booking has expired, removing...');
                localStorage.removeItem('currentBooking');
                localStorage.removeItem('hasActiveBooking');
              }
            } catch (parseError) {
              console.error('❌ Error parsing localStorage booking:', parseError);
            }
          }

          // Check user data for active bookings
          const userData = JSON.parse(localStorage.getItem('user_data') || '{}');
          const currentUser = JSON.parse(localStorage.getItem('current_user') || '{}');
          const userInfo = userData[currentUser?.vehicleId];
          
          if (userInfo && userInfo.activeBookings && userInfo.activeBookings.length > 0) {
            const now = getIndianTime();
            const activeBooking = userInfo.activeBookings.find(booking => {
              const endTime = getIndianTime(new Date(booking.endTime));
              return now <= endTime;
            });
            
            if (activeBooking) {
              console.log('📋 Found active booking in user data:', activeBooking);
              
              // Ensure spotData exists
              if (!activeBooking.spotData && activeBooking.spotId) {
                const spotParts = activeBooking.spotId.split('-');
                if (spotParts.length === 3) {
                  activeBooking.spotData = {
                    id: activeBooking.spotId,
                    floor: parseInt(spotParts[0]),
                    division: parseInt(spotParts[1]),
                    spotNumber: parseInt(spotParts[2]),
                    closestEntrance: parseInt(spotParts[1]) <= 5 ? 'main' : 'rear'
                  };
                }
              }
              
              localStorage.setItem('currentBooking', JSON.stringify(activeBooking));
              localStorage.setItem('hasActiveBooking', 'true');
              return { success: true, data: activeBooking };
            }
          }

          console.log('📋 No current booking found, generating demo booking...');
          return this.generateDemoBooking();
          
        } catch (error) {
          console.error('Error getting user booking:', error);
          return this.generateDemoBooking();
        }
      },

      // Generate demo booking for navigation
      generateDemoBooking() {
        console.log('🎯 Generating demo booking...');
        
        const randomFloor = Math.floor(Math.random() * 5) + 1;
        const randomDivision = Math.floor(Math.random() * 10) + 1;
        const randomSpot = Math.floor(Math.random() * 20) + 1;
        const spotId = `${randomFloor}-${randomDivision.toString().padStart(2, '0')}-${randomSpot.toString().padStart(2, '0')}`;
        
        const bookingStart = getIndianTime();
        const bookingEnd = getIndianTime(new Date(bookingStart.getTime() + (2 * 60 * 60 * 1000)));
        
        const demoBooking = {
          bookingId: 'BK-' + Date.now(),
          spotId: spotId,
          startTime: getIndianTimeISO(bookingStart),
          endTime: getIndianTimeISO(bookingEnd),
          userId: 'demo-user',
          spotData: {
            id: spotId,
            floor: randomFloor,
            division: randomDivision,
            spotNumber: randomSpot,
            closestEntrance: randomDivision <= 5 ? 'main' : 'rear'
          }
        };
        
        console.log('✅ Demo booking generated:', demoBooking);
        
        return {
          success: true,
          data: demoBooking
        };
      },

      // FIXED: Extend booking using AWS /book-spot endpoint with proper time handling
      async extendBooking(bookingId, extensionHours = 1) {
        try {
          console.log('📡 Extending booking via AWS /book-spot endpoint...');
          console.log('📝 Booking ID:', bookingId);
          console.log('⏰ Extension Hours:', extensionHours);
          
          // Get current user and booking info
          const currentUser = JSON.parse(localStorage.getItem('current_user') || '{}');
          const currentBookingData = JSON.parse(localStorage.getItem('currentBooking') || '{}');
          
          console.log('👤 Current User:', currentUser);
          console.log('📋 Current Booking:', currentBookingData);
          
          // Convert frontend spot ID to AWS format if needed
          const awsSpotId = currentBookingData.spotId ? this.convertFrontendToAWSFormat(currentBookingData.spotId) : null;
          
          // Prepare request data
          const requestData = {
            action: 'extend',
            spotId: awsSpotId || currentBookingData.spotId,
            bookingId: bookingId,
            extensionHours: extensionHours,
            userId: currentUser.id || currentUser.vehicleId,
            vehicleId: currentUser.vehicleId,
            timestamp: getIndianTimeISO()
          };
          
          console.log('📤 Sending request data:', requestData);

          const response = await fetch(`${this.baseUrl}/book-spot`, {
            method: 'PUT',
            headers: { 
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            body: JSON.stringify(requestData)
          });

          console.log('📥 Response status:', response.status);
          
          if (response.ok) {
            const result = await response.json();
            console.log('✅ Booking extended via AWS successfully:', result);
            
            // Calculate new end time using Indian time
            const currentEndTime = getIndianTime(new Date(currentBookingData.endTime));
            const newEndTime = new Date(currentEndTime.getTime() + (extensionHours * 60 * 60 * 1000));
            
            return {
              success: true,
              data: {
                message: 'Booking extended successfully via AWS',
                newEndTime: getIndianTimeISO(newEndTime)
              }
            };
          } else {
            // Get more details about the error
            let errorText = '';
            try {
              const errorData = await response.json();
              errorText = errorData.message || errorData.error || JSON.stringify(errorData);
              console.log('❌ AWS Error Response:', errorData);
            } catch (e) {
              errorText = await response.text();
              console.log('❌ AWS Error Text:', errorText);
            }
            
            console.warn(`⚠️ AWS extend failed with status: ${response.status}, error: ${errorText}`);
            
            // For 502 errors, AWS backend is having issues - skip to local extension
            if (response.status === 502) {
              console.log('🔄 AWS backend unavailable (502), using local extension immediately');
              throw new Error('AWS backend temporarily unavailable');
            }
            
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
        } catch (error) {
          console.warn('⚠️ AWS extend failed, using local extension:', error);
          
          // Local extension using Indian time
          console.log('🔄 Using local extension (AWS backend unavailable)');
          
          const currentBookingData = JSON.parse(localStorage.getItem('currentBooking') || '{}');
          const currentEndTime = getIndianTime(new Date(currentBookingData.endTime));
          const newEndTime = new Date(currentEndTime.getTime() + (extensionHours * 60 * 60 * 1000));
          
          return {
            success: true,
            data: {
              message: 'Booking extended successfully (AWS temporarily unavailable)',
              newEndTime: getIndianTimeISO(newEndTime)
            }
          };
        }
      }
    };

    // Global variables
    let currentFloor = 1;
    let selectedDivision = null;
    let userBooking = null;
    let navigationActive = false;
    let currentStep = 0;
    let bookingEndTime = null;
    let parkingData = {};
    let isOfflineMode = false;

    // FIXED: Initialize page with real AWS data and proper time handling
    async function initializePage() {
      try {
        showLoadingState();
        
        // Start time display
        updateTimeDisplay();
        setInterval(updateTimeDisplay, 1000);
        
        // Test AWS connection
        const awsConnected = await SmartParkAPI.testConnection();
        isOfflineMode = !awsConnected;
        
        if (awsConnected) {
          console.log('☁️ Connected to AWS backend');
          showNotification('☁️ Connected to live AWS backend', '#00d4aa');
        } else {
          console.log('📱 Running in offline mode');
          showNotification('📱 Running in offline mode', '#fdcb6e');
        }
        
        // Get user booking from AWS or localStorage
        const bookingResponse = await SmartParkAPI.getUserBooking();
        if (!bookingResponse.success) {
          throw new Error('Failed to fetch booking data');
        }
        
        userBooking = bookingResponse.data;
        console.log('📋 User booking loaded:', userBooking);
        
        // Get parking layout from AWS
        const layoutResponse = await SmartParkAPI.getParkingLayout();
        if (!layoutResponse.success) {
          throw new Error('Failed to fetch parking layout');
        }
        
        parkingData = layoutResponse.layout.floors;
        
        // Update displays
        hideLoadingState();
        updateBookingInfo();
        generateNavigationSteps();
        
        // Set initial floor to user's floor
        if (userBooking.spotData && userBooking.spotData.floor) {
          currentFloor = userBooking.spotData.floor;
          updateFloorButtons();
          generateDivisionGrid();
        }
        
        // FIXED: Start timer with proper Indian time
        if (userBooking.endTime) {
          bookingEndTime = getIndianTime(new Date(userBooking.endTime));
          startTimer();
        }
        
        // Show data source notification
        if (layoutResponse.layout.dataSource === 'aws_dynamodb') {
          showNotification('📡 Live data from AWS sensors', '#4ECDC4');
        } else {
          showNotification('📱 Using demo data', '#fdcb6e');
        }
        
        // Show welcome message
        setTimeout(() => {
          if (userBooking.spotData) {
            showNotification(`🎯 Navigate to spot ${userBooking.spotData.id}`, '#4ECDC4');
          }
        }, 2000);
        
      } catch (error) {
        console.error('Error initializing page:', error);
        hideLoadingState();
        showErrorMessage('Failed to load booking data. Please try again.');
      }
    }

    // Show/hide loading states
    function showLoadingState() {
      document.querySelectorAll('.loading').forEach(el => {
        el.classList.add('loading');
      });
    }

    function hideLoadingState() {
      document.querySelectorAll('.loading').forEach(el => {
        el.classList.remove('loading');
      });
    }

    // Update booking information
    function updateBookingInfo() {
      if (!userBooking || !userBooking.spotData) {
        console.error('❌ No booking data available');
        return;
      }
      
      const { spotData } = userBooking;
      
      document.getElementById('spotInfo').textContent = `Spot ${spotData.id}`;
      document.getElementById('locationInfo').textContent = `Floor ${spotData.floor}, Division ${spotData.division}`;
      document.getElementById('infoSpot').textContent = spotData.id;
      document.getElementById('infoDivision').textContent = `D${spotData.division}`;
      document.getElementById('infoFloor').textContent = `Floor ${spotData.floor}`;
      document.getElementById('infoEntrance').textContent = spotData.closestEntrance?.toUpperCase() || 'MAIN';
    }

    // Generate navigation steps with validation
    function generateNavigationSteps() {
      const container = document.getElementById('navigationSteps');
      
      if (!userBooking || !userBooking.spotData) {
        console.error('❌ Cannot generate navigation steps: missing booking data');
        container.innerHTML = '<div style="color: white; text-align: center; padding: 20px;">⚠️ Booking data unavailable</div>';
        return;
      }
      
      const { spotData } = userBooking;
      
      const steps = [
        { icon: '🚪', title: 'Enter Building', detail: 'Drive through the main entrance gate' },
        { icon: '🛗', title: `Floor ${spotData.floor}`, detail: spotData.floor === 1 ? 'Stay on ground level' : `Take elevator to floor ${spotData.floor}` },
        { icon: '🧭', title: `Division ${spotData.division}`, detail: `Navigate to division ${spotData.division} area` },
        { icon: '🚗', title: `Spot ${spotData.id}`, detail: `Find and park in spot ${spotData.id}` },
        { icon: '✅', title: 'Confirm Arrival', detail: 'Tap confirm when parked' }
      ];

      container.innerHTML = steps.map((step, index) => `
        <div class="step-item" id="step-${index}">
          <div class="step-number">${step.icon}</div>
          <div class="step-text">
            <div class="step-title">${step.title}</div>
            <div class="step-detail">${step.detail}</div>
          </div>
        </div>
      `).join('');
    }

    // Update floor buttons
    function updateFloorButtons() {
      document.querySelectorAll('.floor-btn').forEach(btn => {
        btn.classList.remove('active');
        if (parseInt(btn.dataset.floor) === currentFloor) {
          btn.classList.add('active');
        }
      });
    }

    // Generate division grid for current floor
    function generateDivisionGrid() {
      const container = document.getElementById('divisionGrid');
      
      if (!userBooking || !userBooking.spotData) {
        console.error('❌ No user booking data for division grid');
        return;
      }
      
      const userFloor = userBooking.spotData.floor;
      const userDivision = userBooking.spotData.division;
      
      container.innerHTML = '';
      
      for (let division = 1; division <= PARKING_CONFIG.DIVISIONS_PER_FLOOR; division++) {
        const divisionData = parkingData[currentFloor]?.[division] || {};
        const availableSpots = Object.values(divisionData).filter(spot => spot && spot.available).length;
        
        const divisionCard = document.createElement('div');
        divisionCard.className = 'division-card';
        divisionCard.dataset.division = division;
        
        // Highlight user's division if on user's floor
        if (currentFloor === userFloor && division === userDivision) {
          divisionCard.classList.add('user-division');
        }
        
        divisionCard.innerHTML = `
          <div class="division-number">D${division}</div>
          <div class="division-status">${availableSpots}/${PARKING_CONFIG.SPOTS_PER_DIVISION} free</div>
        `;
        
        divisionCard.addEventListener('click', () => selectDivision(division));
        container.appendChild(divisionCard);
      }
    }

    // Select division and show spots
    function selectDivision(division) {
      selectedDivision = division;
      
      // Update division selection
      document.querySelectorAll('.division-card').forEach(card => {
        card.classList.remove('selected');
      });
      document.querySelector(`[data-division="${division}"]`).classList.add('selected');
      
      // Update spots display
      document.getElementById('selectedDivisionName').textContent = division;
      generateSpotsGrid();
      document.getElementById('spotsContainer').classList.add('active');
    }

    // Generate spots grid for selected division
    function generateSpotsGrid() {
      const container = document.getElementById('spotsGrid');
      const divisionData = parkingData[currentFloor]?.[selectedDivision] || {};
      const userSpotId = userBooking?.spotData?.id;
      
      container.innerHTML = '';
      
      for (let spot = 1; spot <= PARKING_CONFIG.SPOTS_PER_DIVISION; spot++) {
        const spotData = divisionData[spot] || { available: true };
        const spotId = `${currentFloor}-${selectedDivision.toString().padStart(2, '0')}-${spot.toString().padStart(2, '0')}`;
        
        const spotElement = document.createElement('div');
        spotElement.className = 'parking-spot';
        spotElement.textContent = spot.toString().padStart(2, '0');
        
        // Determine spot status
        if (spotId === userSpotId) {
          spotElement.classList.add('spot-user');
        } else if (spotData.available) {
          spotElement.classList.add('spot-available');
        } else {
          spotElement.classList.add('spot-occupied');
        }
        
        container.appendChild(spotElement);
      }
    }

    // Floor button event listeners
    document.addEventListener('DOMContentLoaded', () => {
      // Add floor button listeners
      document.querySelectorAll('.floor-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          currentFloor = parseInt(btn.dataset.floor);
          updateFloorButtons();
          generateDivisionGrid();
          
          // Hide spots container when changing floors
          document.getElementById('spotsContainer').classList.remove('active');
          selectedDivision = null;
        });
      });
      
      // Initialize page
      initializePage();
    });

    // Start navigation sequence
    function startNavigation() {
      if (navigationActive) return;
      
      navigationActive = true;
      const button = event.target.closest('.nav-btn');
      button.innerHTML = '<span class="btn-icon">🚶‍♂️</span><span>Navigating...</span>';
      button.disabled = true;
      
      // Reset steps
      currentStep = 0;
      
      // Start step progression
      const stepInterval = setInterval(() => {
        // Remove active class from all steps
        document.querySelectorAll('.step-item').forEach(step => {
          step.classList.remove('active');
        });
        
        if (currentStep >= 5) {
          clearInterval(stepInterval);
          button.innerHTML = '<span class="btn-icon">✅</span><span>Arrived!</span>';
          button.style.background = 'linear-gradient(135deg, #2ecc71, #1abc9c)';
          
          // Show arrival confirmation
          setTimeout(() => {
            if (confirm('Have you arrived at your parking spot?')) {
              showNotification('🎉 Arrival confirmed! Enjoy your parking.', '#2ecc71');
              button.innerHTML = '<span class="btn-icon">✅</span><span>Confirmed</span>';
            }
          }, 1000);
          return;
        }
        
        // Activate current step
        const currentStepEl = document.getElementById(`step-${currentStep}`);
        if (currentStepEl) {
          currentStepEl.classList.add('active');
          
          // Show step notification
          const stepTexts = ['Enter Building', 'Go to Floor', 'Find Division', 'Locate Spot', 'Park & Confirm'];
          showNotification(`📍 ${stepTexts[currentStep]}`, '#f093fb');
        }
        
        currentStep++;
      }, 3000); // 3 seconds per step
    }

    // FIXED: Timer functionality with proper Indian time handling
    function startTimer() {
      updateTimerDisplay();
      setInterval(updateTimerDisplay, 1000); // Update every second for real-time accuracy
    }

    function updateTimerDisplay() {
      if (!bookingEndTime) {
        document.getElementById('timeRemaining').textContent = 'No booking';
        return;
      }
      
      // Use Indian time consistently
      const now = getIndianTime();
      const endTime = getIndianTime(bookingEndTime);
      const diff = endTime - now;
      
      console.log('⏰ Timer update (Indian Time):', {
        now: formatIndianTime(now),
        endTime: formatIndianTime(endTime),
        diff: diff,
        diffMinutes: Math.floor(diff / (1000 * 60))
      });
      
      if (diff <= 0) {
        document.getElementById('timeRemaining').textContent = 'EXPIRED';
        document.getElementById('timeRemaining').style.color = '#ff6b6b';
        return;
      }
      
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);
      
      if (hours > 0) {
        document.getElementById('timeRemaining').textContent = `${hours}h ${minutes}m ${seconds}s`;
      } else if (minutes > 0) {
        document.getElementById('timeRemaining').textContent = `${minutes}m ${seconds}s`;
      } else {
        document.getElementById('timeRemaining').textContent = `${seconds}s`;
      }
      
      document.getElementById('timeRemaining').style.color = 'white';
    }

    // FIXED: Extend booking using real AWS API with proper time handling
    async function extendBooking() {
      if (!bookingEndTime || !userBooking) {
        showNotification('❌ No active booking to extend', '#ff6b6b');
        return;
      }
      
      try {
        const button = event.target.closest('.nav-btn');
        const originalText = button.innerHTML;
        button.innerHTML = '<span class="btn-icon">⏳</span><span>Extending...</span>';
        button.disabled = true;
        
        console.log('🔄 Extending booking...');
        console.log('📋 Current booking:', userBooking);
        console.log('⏰ Current end time:', formatIndianTime(bookingEndTime));
        
        // Try AWS API with retry logic
        let awsSuccess = false;
        let retryCount = 0;
        const maxRetries = 2;
        
        while (!awsSuccess && retryCount < maxRetries) {
          try {
            console.log(`🔄 Attempt ${retryCount + 1} to extend booking via AWS...`);
            
            const response = await SmartParkAPI.extendBooking(userBooking.bookingId || userBooking.id, 1);
            if (response.success) {
              awsSuccess = true;
              
              // Update booking end time using Indian time
              const newEndTime = getIndianTime(new Date(response.data.newEndTime));
              bookingEndTime = newEndTime;
              
              // Update userBooking object
              userBooking.endTime = response.data.newEndTime;
              
              // Update localStorage
              localStorage.setItem('currentBooking', JSON.stringify(userBooking));
              
              // Update user data
              const userData = JSON.parse(localStorage.getItem('user_data') || '{}');
              const currentUser = JSON.parse(localStorage.getItem('current_user') || '{}');
              if (userData[currentUser?.vehicleId] && userData[currentUser.vehicleId].activeBookings) {
                const bookingIndex = userData[currentUser.vehicleId].activeBookings.findIndex(b => 
                  b.id === userBooking.id || b.bookingId === userBooking.bookingId
                );
                if (bookingIndex >= 0) {
                  userData[currentUser.vehicleId].activeBookings[bookingIndex].endTime = response.data.newEndTime;
                  localStorage.setItem('user_data', JSON.stringify(userData));
                }
              }
              
              updateTimerDisplay();
              showNotification('⏱️ Booking extended by 1 hour via AWS!', '#f093fb');
              console.log('✅ AWS extension successful!');
              console.log('🕒 New end time:', formatIndianTime(newEndTime));
              break;
            }
          } catch (awsError) {
            retryCount++;
            console.log(`⚠️ AWS attempt ${retryCount} failed:`, awsError.message);
            
            if (retryCount < maxRetries) {
              console.log('🔄 Retrying AWS extension...');
              await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second before retry
            }
          }
        }
        
        // If AWS failed after retries, use local extension
        if (!awsSuccess) {
          console.log('❌ AWS extension failed after retries, using local fallback');
          
          // Local extension using Indian time
          const currentEndTime = getIndianTime(bookingEndTime);
          const newEndTime = new Date(currentEndTime.getTime() + 60 * 60 * 1000);
          
          bookingEndTime = newEndTime;
          userBooking.endTime = getIndianTimeISO(newEndTime);
          localStorage.setItem('currentBooking', JSON.stringify(userBooking));
          
          updateTimerDisplay();
          
          // Show user that extension worked but AWS sync failed
          showNotification('⏱️ Booking extended locally (AWS sync pending)', '#fdcb6e');
          console.log('🕒 Local extension - New end time:', formatIndianTime(newEndTime));
          
          // Try to queue the AWS update for later
          queueAWSUpdate();
        }
        
        button.innerHTML = originalText;
        button.disabled = false;
        
      } catch (error) {
        console.error('Error extending booking:', error);
        showNotification('❌ Failed to extend booking. Please try again.', '#ff6b6b');
        
        const button = event.target.closest('.nav-btn');
        button.innerHTML = '<span class="btn-icon">⏱️</span><span>Extend Booking</span>';
        button.disabled = false;
      }
    }

    // Queue AWS updates for when backend is available
    function queueAWSUpdate() {
      const pendingUpdates = JSON.parse(localStorage.getItem('pendingAWSUpdates') || '[]');
      pendingUpdates.push({
        type: 'extend',
        bookingId: userBooking.bookingId || userBooking.id,
        spotId: userBooking.spotId,
        newEndTime: userBooking.endTime,
        timestamp: getIndianTimeISO()
      });
      localStorage.setItem('pendingAWSUpdates', JSON.stringify(pendingUpdates));
      console.log('📝 Queued AWS update for later sync');
    }

    // Show notification
    function showNotification(message, color) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: ${color};
        color: white;
        padding: 15px 25px;
        border-radius: 25px;
        font-weight: 600;
        font-size: 0.95rem;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        z-index: 1000;
        animation: slideInDown 0.5s ease-out;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.2);
      `;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.animation = 'slideOutUp 0.5s ease-in forwards';
        setTimeout(() => notification.remove(), 500);
      }, 4000);
    }

    // Show error message
    function showErrorMessage(message) {
      document.body.innerHTML = `
        <div style="display: flex; justify-content: center; align-items: center; height: 100vh; flex-direction: column; text-align: center; padding: 20px;">
          <div style="background: rgba(255,255,255,0.1); backdrop-filter: blur(20px); border-radius: 30px; padding: 50px; max-width: 500px; border: 1px solid rgba(255,255,255,0.2);">
            <h1 style="color: white; font-size: 2.5rem; margin-bottom: 20px;">⚠️</h1>
            <h2 style="color: white; font-size: 1.5rem; margin-bottom: 15px;">Connection Error</h2>
            <p style="color: rgba(255,255,255,0.8); margin-bottom: 30px; line-height: 1.5;">
              ${message}
            </p>
            <button onclick="location.reload()" 
                    style="background: linear-gradient(135deg, #4ECDC4, #44A08D); 
                           color: white; 
                           border: none; 
                           padding: 18px 35px; 
                           border-radius: 25px; 
                           font-size: 1.1rem; 
                           font-weight: 700;
                           cursor: pointer;
                           transition: all 0.3s ease;
                           font-family: inherit;"
                    onmouseover="this.style.transform='translateY(-2px)'"
                    onmouseout="this.style.transform='translateY(0)'">
              🔄 Retry
            </button>
          </div>
        </div>
      `;
    }

    // Add CSS for notification animations
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideInDown {
        from { transform: translate(-50%, -100%); opacity: 0; }
        to { transform: translate(-50%, 0); opacity: 1; }
      }
      @keyframes slideOutUp {
        from { transform: translate(-50%, 0); opacity: 1; }
        to { transform: translate(-50%, -100%); opacity: 0; }
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>